diff --git a/ggml/include/ggml-rpc.h b/ggml/include/ggml-rpc.h
index 4e0d210f..c8b6097f 100644
--- a/ggml/include/ggml-rpc.h
+++ b/ggml/include/ggml-rpc.h
@@ -7,6 +7,9 @@
 extern "C" {
 #endif
 
+#define RPC_PROTO_MAJOR_VERSION    1
+#define RPC_PROTO_MINOR_VERSION    0
+#define RPC_PROTO_PATCH_VERSION    0
 #define GGML_RPC_MAX_SERVERS       16
 
 // backend API
diff --git a/ggml/src/ggml-rpc/ggml-rpc.cpp b/ggml/src/ggml-rpc/ggml-rpc.cpp
index 3189ae85..812d9f85 100644
--- a/ggml/src/ggml-rpc/ggml-rpc.cpp
+++ b/ggml/src/ggml-rpc/ggml-rpc.cpp
@@ -4,6 +4,8 @@
 #include "ggml-cpp.h"
 
 #include <cinttypes>
+#include <cerrno>
+#include <cstring>
 #include <string>
 #include <vector>
 #include <memory>
@@ -17,6 +19,7 @@
 #  endif
 #  include <windows.h>
 #  include <winsock2.h>
+#  include <ws2tcpip.h>
 #else
 #  include <arpa/inet.h>
 #  include <sys/socket.h>
@@ -92,12 +95,20 @@ enum rpc_cmd {
     RPC_CMD_GET_DEVICE_MEMORY,
     RPC_CMD_INIT_TENSOR,
     RPC_CMD_GET_ALLOC_SIZE,
+    RPC_CMD_HELLO,
+    RPC_CMD_SUPPORT_OP,
     RPC_CMD_COUNT,
 };
 
 // Try RPC_CMD_SET_TENSOR_HASH first when data size is larger than this threshold
 const size_t HASH_THRESHOLD = 10 * 1024 * 1024;
 
+struct rpc_msg_hello_rsp {
+    uint8_t major;
+    uint8_t minor;
+    uint8_t patch;
+};
+
 struct rpc_msg_get_alloc_size_req {
     rpc_tensor tensor;
 };
@@ -171,6 +182,10 @@ struct rpc_msg_get_device_memory_rsp {
     uint64_t free_mem;
     uint64_t total_mem;
 };
+
+struct rpc_msg_support_op_rsp {
+    uint8_t result;
+};
 #pragma pack(pop)
 
 // RPC data structures
@@ -232,6 +247,18 @@ static bool set_no_delay(sockfd_t sockfd) {
     return ret == 0;
 }
 
+static void set_buf_size(sockfd_t sockfd) {
+    int size = 1 << 20; // 1MiB
+    int ret = setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, (char *)&size, sizeof(int));
+    if (ret != 0) {
+        fprintf(stderr, "Failed to set SO_RCVBUF: %d\n", ret);
+    }
+    ret = setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, (char *)&size, sizeof(int));
+    if (ret != 0) {
+        fprintf(stderr, "Failed to set SO_SNDBUF: %d\n", ret);
+    }
+}
+
 static bool set_reuse_addr(sockfd_t sockfd) {
     int flag = 1;
     int ret = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (char *)&flag, sizeof(int));
@@ -258,6 +285,7 @@ static std::shared_ptr<socket_t> socket_connect(const char * host, int port) {
     }
     memcpy(&addr.sin_addr.s_addr, server->h_addr, server->h_length);
     if (connect(sock_ptr->fd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+        fprintf(stderr, "Failed to connect host '%s:%d': %s\n", host, port, strerror(errno));
         return nullptr;
     }
     return sock_ptr;
@@ -273,6 +301,7 @@ static std::shared_ptr<socket_t> socket_accept(sockfd_t srv_sockfd) {
         fprintf(stderr, "Failed to set TCP_NODELAY\n");
         return nullptr;
     }
+    set_buf_size(client_socket_fd);
     return client_socket;
 }
 
@@ -309,6 +338,31 @@ static bool send_data(sockfd_t sockfd, const void * data, size_t size) {
     while (bytes_sent < size) {
         ssize_t n = send(sockfd, (const char *)data + bytes_sent, size - bytes_sent, 0);
         if (n < 0) {
+            int err = errno;
+            if (err == EINTR || err == EAGAIN || err == EWOULDBLOCK) {
+                GGML_LOG_WARN("[%s] interrupted: data range = [%p, %p), bytes_sent = %zu, bytes_target = %zu, errno = %d, errmsg = %s, retrying...\n", __func__, data, (char *)data + size, bytes_sent, size, err, strerror(err));
+                continue; // try again
+            }
+            if (err != 0) {
+                GGML_LOG_ERROR("[%s] failed to send data: data range = [%p, %p), bytes_sent = %zu, bytes_target = %zu, errno = %d, errmsg = %s\n", __func__, data, (char *)data + size, bytes_sent, size, err, strerror(err));
+                int serr = 0;
+                socklen_t serr_len = sizeof(serr);
+                int ret = getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (char *)&serr, &serr_len);
+                if (ret < 0) {
+                    err = errno;
+                    GGML_LOG_ERROR("[%s] failed to get peer socket error: errno = %d, errmsg = %s\n", __func__, err, strerror(err));
+                } else if (serr != 0) {
+                    GGML_LOG_ERROR("[%s] peer socket error: errno = %d, errmsg = %s\n", __func__, serr, strerror(serr));
+                } else {
+                    struct sockaddr_in sin{};
+                    socklen_t addr_len = sizeof(sin);
+                    ret                = getpeername(sockfd, (struct sockaddr *)&sin, &addr_len);
+                    if (ret < 0) {
+                        err = errno;
+                        GGML_LOG_ERROR("[%s] peer may have been disconnected: errno = %d, errmsg = %s\n", __func__, err, strerror(err));
+                    }
+                }
+            }
             return false;
         }
         bytes_sent += n;
@@ -321,6 +375,31 @@ static bool recv_data(sockfd_t sockfd, void * data, size_t size) {
     while (bytes_recv < size) {
         ssize_t n = recv(sockfd, (char *)data + bytes_recv, size - bytes_recv, 0);
         if (n <= 0) {
+            int err = errno;
+            if (err == EINTR || err == EAGAIN || err == EWOULDBLOCK) {
+                GGML_LOG_WARN("[%s] interrupted: data range = [%p, %p), bytes_recv = %zu, bytes_target = %zu, errno = %d, errmsg = %s, retrying...\n", __func__, data, (char *)data + size, bytes_recv, size, err, strerror(err));
+                continue; // try again
+            }
+            if (err != 0 && err != ESRCH) {
+                GGML_LOG_ERROR("[%s] failed to recv data: data range = [%p, %p), bytes_recv = %zu, bytes_target = %zu, errno = %d, errmsg = %s\n", __func__, data, (char *)data + size, bytes_recv, size, err, strerror(err));
+                int serr = 0;
+                socklen_t serr_len = sizeof(serr);
+                int ret = getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (char *)&serr, &serr_len);
+                if (ret < 0) {
+                    err = errno;
+                    GGML_LOG_ERROR("[%s] failed to get peer socket error: errno = %d, errmsg = %s\n", __func__, err, strerror(err));
+                } else if (serr != 0) {
+                    GGML_LOG_ERROR("[%s] peer socket error: errno = %d, errmsg = %s\n", __func__, serr, strerror(serr));
+                } else {
+                    struct sockaddr_in sin{};
+                    socklen_t addr_len = sizeof(sin);
+                    ret                = getpeername(sockfd, (struct sockaddr *)&sin, &addr_len);
+                    if (ret < 0) {
+                        err = errno;
+                        GGML_LOG_ERROR("[%s] peer may have been disconnected: errno = %d, errmsg = %s\n", __func__, err, strerror(err));
+                    }
+                }
+            }
             return false;
         }
         bytes_recv += n;
@@ -330,25 +409,37 @@ static bool recv_data(sockfd_t sockfd, void * data, size_t size) {
 
 static bool send_msg(sockfd_t sockfd, const void * msg, size_t msg_size) {
     if (!send_data(sockfd, &msg_size, sizeof(msg_size))) {
+        GGML_LOG_ERROR("[%s] failed to send msg size\n", __func__);
         return false;
     }
-    return send_data(sockfd, msg, msg_size);
+    bool ret = send_data(sockfd, msg, msg_size);
+    if (!ret) {
+        GGML_LOG_ERROR("[%s] failed to send msg data\n", __func__);
+    }
+    return ret;
 }
 
 static bool recv_msg(sockfd_t sockfd, void * msg, size_t msg_size) {
     uint64_t size;
     if (!recv_data(sockfd, &size, sizeof(size))) {
+        GGML_LOG_ERROR("[%s] failed to recv msg size\n", __func__);
         return false;
     }
     if (size != msg_size) {
+        GGML_LOG_ERROR("[%s] failed: msg size mismatch, expected %zu, got %" PRIu64 "\n", __func__, msg_size, size);
         return false;
     }
-    return recv_data(sockfd, msg, msg_size);
+    bool ret = recv_data(sockfd, msg, msg_size);
+    if (!ret) {
+        GGML_LOG_ERROR("[%s] failed to recv msg data\n", __func__);
+    }
+    return ret;
 }
 
 static bool recv_msg(sockfd_t sockfd, std::vector<uint8_t> & input) {
     uint64_t size;
     if (!recv_data(sockfd, &size, sizeof(size))) {
+        GGML_LOG_ERROR("[%s] failed to recv msg size\n", __func__);
         return false;
     }
     try {
@@ -357,7 +448,11 @@ static bool recv_msg(sockfd_t sockfd, std::vector<uint8_t> & input) {
         fprintf(stderr, "Failed to allocate input buffer of size %" PRIu64 "\n", size);
         return false;
     }
-    return recv_data(sockfd, input.data(), size);
+    bool ret = recv_data(sockfd, input.data(), size);
+    if (!ret) {
+        GGML_LOG_ERROR("[%s] failed to recv msg data\n", __func__);
+    }
+    return ret;
 }
 
 static bool parse_endpoint(const std::string & endpoint, std::string & host, int & port) {
@@ -375,24 +470,30 @@ static bool parse_endpoint(const std::string & endpoint, std::string & host, int
 static bool send_rpc_cmd(const std::shared_ptr<socket_t> & sock, enum rpc_cmd cmd, const void * input, size_t input_size, void * output, size_t output_size) {
     uint8_t cmd_byte = cmd;
     if (!send_data(sock->fd, &cmd_byte, sizeof(cmd_byte))) {
+        GGML_LOG_ERROR("[%s] failed to send command, cmd = %d\n", __func__, cmd);
         return false;
     }
     if (!send_data(sock->fd, &input_size, sizeof(input_size))) {
+        GGML_LOG_ERROR("[%s] failed to send input, cmd = %d, size = %zu\n", __func__, cmd, input_size);
         return false;
     }
     if (!send_data(sock->fd, input, input_size)) {
+        GGML_LOG_ERROR("[%s] failed to send input data, cmd = %d, size = %zu\n", __func__, cmd, input_size);
         return false;
     }
     // TODO: currently the output_size is always known, do we need support for commands with variable output size?
     // even if we do, we can skip sending output_size from the server for commands with known output size
     uint64_t out_size;
     if (!recv_data(sock->fd, &out_size, sizeof(out_size))) {
+        GGML_LOG_ERROR("[%s] failed to recv output size, cmd = %d\n", __func__, cmd);
         return false;
     }
     if (out_size != output_size) {
+        GGML_LOG_ERROR("[%s] failed: output size mismatch, cmd = %d, expected %zu, got %llu\n", __func__, cmd, output_size, out_size);
         return false;
     }
     if (!recv_data(sock->fd, output, output_size)) {
+        GGML_LOG_ERROR("[%s] failed to recv output data, cmd = %d, size = %zu\n", __func__, cmd, output_size);
         return false;
     }
     return true;
@@ -400,6 +501,20 @@ static bool send_rpc_cmd(const std::shared_ptr<socket_t> & sock, enum rpc_cmd cm
 
 // RPC client-side implementation
 
+static bool check_server_version(const std::shared_ptr<socket_t> & sock) {
+    rpc_msg_hello_rsp response;
+    bool status = send_rpc_cmd(sock, RPC_CMD_HELLO, nullptr, 0, &response, sizeof(response));
+    GGML_ASSERT(status && "failed to check version");
+    if (response.major != RPC_PROTO_MAJOR_VERSION || response.minor > RPC_PROTO_MINOR_VERSION) {
+        fprintf(stderr, "RPC server version mismatch: %d.%d.%d\n", response.major, response.minor, response.patch);
+        return false;
+    }
+    if (response.minor != RPC_PROTO_MINOR_VERSION || response.patch != RPC_PROTO_PATCH_VERSION) {
+        fprintf(stderr, "WARNING: RPC server version mismatch: %d.%d.%d\n", response.major, response.minor, response.patch);
+    }
+    return true;
+}
+
 static std::shared_ptr<socket_t> get_socket(const std::string & endpoint) {
     static std::mutex mutex;
     std::lock_guard<std::mutex> lock(mutex);
@@ -433,6 +548,9 @@ static std::shared_ptr<socket_t> get_socket(const std::string & endpoint) {
     if (sock == nullptr) {
         return nullptr;
     }
+    if (!check_server_version(sock)) {
+        return nullptr;
+    }
     GGML_PRINT_DEBUG("[%s] connected to %s, sockfd=%d\n", __func__, endpoint.c_str(), sock->fd);
     sockets[endpoint] = sock;
     return sock;
@@ -442,7 +560,7 @@ static void ggml_backend_rpc_buffer_free_buffer(ggml_backend_buffer_t buffer) {
     ggml_backend_rpc_buffer_context * ctx = (ggml_backend_rpc_buffer_context *)buffer->context;
     rpc_msg_free_buffer_req request = {ctx->remote_ptr};
     bool status = send_rpc_cmd(ctx->sock, RPC_CMD_FREE_BUFFER, &request, sizeof(request), nullptr, 0);
-    GGML_ASSERT(status);
+    GGML_UNUSED(status);
     delete ctx;
 }
 
@@ -454,7 +572,7 @@ static void * ggml_backend_rpc_buffer_get_base(ggml_backend_buffer_t buffer) {
     rpc_msg_buffer_get_base_req request = {ctx->remote_ptr};
     rpc_msg_buffer_get_base_rsp response;
     bool status = send_rpc_cmd(ctx->sock, RPC_CMD_BUFFER_GET_BASE, &request, sizeof(request), &response, sizeof(response));
-    GGML_ASSERT(status);
+    GGML_ASSERT(status && "failed to get buffer base");
     ctx->base_ptr = reinterpret_cast<void *>(response.base_ptr);
     return ctx->base_ptr;
 }
@@ -463,7 +581,7 @@ static rpc_tensor serialize_tensor(const ggml_tensor * tensor) {
     rpc_tensor result;
     result.id = reinterpret_cast<uint64_t>(tensor);
     result.type = tensor->type;
-    if (tensor->buffer) {
+    if (tensor->buffer && tensor->buffer->context) {
         ggml_backend_buffer_t buffer = tensor->buffer;
         ggml_backend_rpc_buffer_context * ctx = (ggml_backend_rpc_buffer_context *)buffer->context;
         result.buffer = ctx->remote_ptr;
@@ -501,7 +619,7 @@ static enum ggml_status ggml_backend_rpc_buffer_init_tensor(ggml_backend_buffer_
         request.tensor = serialize_tensor(tensor);
 
         bool status = send_rpc_cmd(ctx->sock, RPC_CMD_INIT_TENSOR, &request, sizeof(request), nullptr, 0);
-        GGML_ASSERT(status);
+        GGML_ASSERT(status && "failed to init tensor");
     }
     return GGML_STATUS_SUCCESS;
 }
@@ -519,7 +637,7 @@ static void ggml_backend_rpc_buffer_set_tensor(ggml_backend_buffer_t buffer, ggm
         memcpy(input.data() + sizeof(rpc_tensor) + sizeof(offset), &hash, sizeof(hash));
         rpc_msg_set_tensor_hash_rsp response;
         bool status = send_rpc_cmd(ctx->sock, RPC_CMD_SET_TENSOR_HASH, input.data(), input.size(), &response, sizeof(response));
-        GGML_ASSERT(status);
+        GGML_ASSERT(status && "failed to set tensor hash");
         if (response.result) {
             // the server has the same data, no need to send it
             return;
@@ -532,7 +650,7 @@ static void ggml_backend_rpc_buffer_set_tensor(ggml_backend_buffer_t buffer, ggm
     memcpy(input.data() + sizeof(rpc_tensor), &offset, sizeof(offset));
     memcpy(input.data() + sizeof(rpc_tensor) + sizeof(offset), data, size);
     bool status = send_rpc_cmd(ctx->sock, RPC_CMD_SET_TENSOR, input.data(), input.size(), nullptr, 0);
-    GGML_ASSERT(status);
+    GGML_ASSERT(status && "failed to set tensor");
 }
 
 static void ggml_backend_rpc_buffer_get_tensor(ggml_backend_buffer_t buffer, const ggml_tensor * tensor, void * data, size_t offset, size_t size) {
@@ -542,7 +660,7 @@ static void ggml_backend_rpc_buffer_get_tensor(ggml_backend_buffer_t buffer, con
     request.offset = offset;
     request.size = size;
     bool status = send_rpc_cmd(ctx->sock, RPC_CMD_GET_TENSOR, &request, sizeof(request), data, size);
-    GGML_ASSERT(status);
+    GGML_ASSERT(status && "failed to get tensor");
 }
 
 static bool ggml_backend_rpc_buffer_cpy_tensor(ggml_backend_buffer_t buffer, const ggml_tensor * src, ggml_tensor * dst) {
@@ -560,7 +678,7 @@ static bool ggml_backend_rpc_buffer_cpy_tensor(ggml_backend_buffer_t buffer, con
     request.dst = serialize_tensor(dst);
     rpc_msg_copy_tensor_rsp response;
     bool status = send_rpc_cmd(ctx->sock, RPC_CMD_COPY_TENSOR, &request, sizeof(request), &response, sizeof(response));
-    GGML_ASSERT(status);
+    GGML_ASSERT(status && "failed to copy tensor");
     return response.result;
 }
 
@@ -568,7 +686,7 @@ static void ggml_backend_rpc_buffer_clear(ggml_backend_buffer_t buffer, uint8_t
     ggml_backend_rpc_buffer_context * ctx = (ggml_backend_rpc_buffer_context *)buffer->context;
     rpc_msg_buffer_clear_req request = {ctx->remote_ptr, value};
     bool status = send_rpc_cmd(ctx->sock, RPC_CMD_BUFFER_CLEAR, &request, sizeof(request), nullptr, 0);
-    GGML_ASSERT(status);
+    GGML_ASSERT(status && "failed to clear buffer");
 }
 
 static ggml_backend_buffer_i ggml_backend_rpc_buffer_interface = {
@@ -594,7 +712,7 @@ static ggml_backend_buffer_t ggml_backend_rpc_buffer_type_alloc_buffer(ggml_back
     rpc_msg_alloc_buffer_rsp response;
     auto sock = get_socket(buft_ctx->endpoint);
     bool status = send_rpc_cmd(sock, RPC_CMD_ALLOC_BUFFER, &request, sizeof(request), &response, sizeof(response));
-    GGML_ASSERT(status);
+    GGML_ASSERT(status && "failed to alloc buffer");
     if (response.remote_ptr != 0) {
         ggml_backend_buffer_t buffer = ggml_backend_buffer_init(buft,
             ggml_backend_rpc_buffer_interface,
@@ -609,7 +727,7 @@ static ggml_backend_buffer_t ggml_backend_rpc_buffer_type_alloc_buffer(ggml_back
 static size_t get_alignment(const std::shared_ptr<socket_t> & sock) {
     rpc_msg_get_alignment_rsp response;
     bool status = send_rpc_cmd(sock, RPC_CMD_GET_ALIGNMENT, nullptr, 0, &response, sizeof(response));
-    GGML_ASSERT(status);
+    GGML_ASSERT(status && "failed to get alignment");
     return response.alignment;
 }
 
@@ -621,7 +739,7 @@ static size_t ggml_backend_rpc_buffer_type_get_alignment(ggml_backend_buffer_typ
 static size_t get_max_size(const std::shared_ptr<socket_t> & sock) {
     rpc_msg_get_max_size_rsp response;
     bool status = send_rpc_cmd(sock, RPC_CMD_GET_MAX_SIZE, nullptr, 0, &response, sizeof(response));
-    GGML_ASSERT(status);
+    GGML_ASSERT(status && "failed to get max size");
     return response.max_size;
 }
 
@@ -642,7 +760,7 @@ static size_t ggml_backend_rpc_buffer_type_get_alloc_size(ggml_backend_buffer_ty
 
         rpc_msg_get_alloc_size_rsp response;
         bool status = send_rpc_cmd(sock, RPC_CMD_GET_ALLOC_SIZE, &request, sizeof(request), &response, sizeof(response));
-        GGML_ASSERT(status);
+        GGML_ASSERT(status && "failed to get alloc size");
 
         return response.alloc_size;
     } else {
@@ -720,7 +838,7 @@ static enum ggml_status ggml_backend_rpc_graph_compute(ggml_backend_t backend, g
     rpc_msg_graph_compute_rsp response;
     auto sock = get_socket(rpc_ctx->endpoint);
     bool status = send_rpc_cmd(sock, RPC_CMD_GRAPH_COMPUTE, input.data(), input.size(), &response, sizeof(response));
-    GGML_ASSERT(status);
+    GGML_ASSERT(status && "failed to compute graph");
     return (enum ggml_status)response.result;
 }
 
@@ -794,7 +912,7 @@ bool ggml_backend_is_rpc(ggml_backend_t backend) {
 static void get_device_memory(const std::shared_ptr<socket_t> & sock, size_t * free, size_t * total) {
     rpc_msg_get_device_memory_rsp response;
     bool status = send_rpc_cmd(sock, RPC_CMD_GET_DEVICE_MEMORY, nullptr, 0, &response, sizeof(response));
-    GGML_ASSERT(status);
+    GGML_ASSERT(status && "failed to get device memory");
     *free = response.free_mem;
     *total = response.total_mem;
 }
@@ -809,6 +927,31 @@ void ggml_backend_rpc_get_device_memory(const char * endpoint, size_t * free, si
     get_device_memory(sock, free, total);
 }
 
+static bool ggml_backend_rpc_support_op(const char * endpoint, const ggml_tensor * tensor) {
+    std::vector<uint8_t> input;
+    {
+        std::vector<rpc_tensor> tensors;
+        for (int i = 0; i < GGML_MAX_SRC; i++) {
+            if (tensor->src[i] == nullptr) {
+                break;
+            }
+            tensors.push_back(serialize_tensor(tensor->src[i]));
+        }
+        tensors.push_back(serialize_tensor(tensor));
+        // serialization format: | n_tensors (4 bytes) | tensors (n_tensors * sizeof(rpc_tensor)) |
+        uint32_t n_tensors = tensors.size();
+        int input_size = sizeof(uint32_t) + n_tensors * sizeof(rpc_tensor);
+        input.resize(input_size, 0);
+        memcpy(input.data(), &n_tensors, sizeof(n_tensors));
+        memcpy(input.data() + sizeof(n_tensors), tensors.data(), n_tensors * sizeof(rpc_tensor));
+    }
+    rpc_msg_support_op_rsp response;
+    auto sock = get_socket(endpoint);
+    bool status = send_rpc_cmd(sock, RPC_CMD_SUPPORT_OP, input.data(), input.size(), &response, sizeof(response));
+    GGML_ASSERT(status && "failed to check op support");
+    return response.result;
+}
+
 // RPC server-side implementation
 
 class rpc_server {
@@ -818,6 +961,7 @@ public:
     }
     ~rpc_server();
 
+    void hello(rpc_msg_hello_rsp & response);
     void alloc_buffer(const rpc_msg_alloc_buffer_req & request, rpc_msg_alloc_buffer_rsp & response);
     void get_alignment(rpc_msg_get_alignment_rsp & response);
     void get_max_size(rpc_msg_get_max_size_rsp & response);
@@ -831,6 +975,7 @@ public:
     bool graph_compute(const std::vector<uint8_t> & input, rpc_msg_graph_compute_rsp & response);
     bool init_tensor(const rpc_msg_init_tensor_req & request);
     bool get_alloc_size(const rpc_msg_get_alloc_size_req & request, rpc_msg_get_alloc_size_rsp & response);
+    bool support_op(const std::vector<uint8_t> & input, rpc_msg_support_op_rsp & response);
 
 private:
     bool get_cached_file(uint64_t hash, std::vector<uint8_t> & data);
@@ -846,6 +991,13 @@ private:
     std::unordered_set<ggml_backend_buffer_t> buffers;
 };
 
+void rpc_server::hello(rpc_msg_hello_rsp & response) {
+    response.major = RPC_PROTO_MAJOR_VERSION;
+    response.minor = RPC_PROTO_MINOR_VERSION;
+    response.patch = RPC_PROTO_PATCH_VERSION;
+    GGML_PRINT_DEBUG("[%s] version: %d.%d.%d\n", __func__, response.major, response.minor, response.patch);
+}
+
 bool rpc_server::get_alloc_size(const rpc_msg_get_alloc_size_req & request, rpc_msg_get_alloc_size_rsp & response) {
     ggml_backend_buffer_type_t buft;
     struct ggml_init_params params {
@@ -1192,6 +1344,42 @@ bool rpc_server::copy_tensor(const rpc_msg_copy_tensor_req & request, rpc_msg_co
     return true;
 }
 
+bool rpc_server::support_op(const std::vector<uint8_t> & input, rpc_msg_support_op_rsp & response) {
+    // serialization format: | n_tensors (4 bytes) | tensors (n_tensors * sizeof(rpc_tensor)) |
+    if (input.size() < sizeof(uint32_t)) {
+        GGML_LOG_ERROR("[%s] invalid input size\n", __func__);
+        return false;
+    }
+    uint32_t n_tensors;
+    memcpy(&n_tensors, input.data(), sizeof(n_tensors));
+    if (input.size() < sizeof(uint32_t) + n_tensors * sizeof(rpc_tensor)) {
+        GGML_LOG_ERROR("[%s] invalid input size\n", __func__);
+        return false;
+    }
+    const rpc_tensor * tensors = (const rpc_tensor *)(input.data() + sizeof(uint32_t));
+    GGML_PRINT_DEBUG("[%s] n_tensors: %u\n", __func__, n_tensors);
+
+    size_t buf_size = ggml_tensor_overhead()*n_tensors;
+    struct ggml_init_params params {
+        /*.mem_size   =*/ buf_size,
+        /*.mem_buffer =*/ NULL,
+        /*.no_alloc   =*/ true,
+    };
+    struct ggml_context * ctx = ggml_init(params);
+    ggml_tensor * tensor = deserialize_tensor(ctx, &tensors[n_tensors-1]);
+    for (uint32_t i = 0; i < n_tensors-1; i++) {
+        ggml_tensor * src = deserialize_tensor(ctx, &tensors[i]);
+        tensor->src[i] = src;
+    }
+    response.result = true;
+    if (backend->device->iface.supports_op) {
+        response.result = backend->device->iface.supports_op(backend->device, tensor);
+    }
+    ggml_free(ctx);
+
+    return true;
+}
+
 ggml_tensor * rpc_server::create_node(uint64_t id,
                                       struct ggml_context * ctx,
                                       const std::unordered_map<uint64_t, const rpc_tensor*> & tensor_ptrs,
@@ -1271,8 +1459,24 @@ rpc_server::~rpc_server() {
 static void rpc_serve_client(ggml_backend_t backend, const char * cache_dir,
                              sockfd_t sockfd, size_t free_mem, size_t total_mem) {
     rpc_server server(backend, cache_dir);
+    uint8_t cmd;
+    if (!recv_data(sockfd, &cmd, 1)) {
+        return;
+    }
+    // the first command sent by the client must be HELLO
+    if (cmd != RPC_CMD_HELLO) {
+        fprintf(stderr, "Expected HELLO command, update client\n");
+        return;
+    }
+    if (!recv_msg(sockfd, nullptr, 0)) {
+        return;
+    }
+    rpc_msg_hello_rsp response;
+    server.hello(response);
+    if (!send_msg(sockfd, &response, sizeof(response))) {
+        return;
+    }
     while (true) {
-        uint8_t cmd;
         if (!recv_data(sockfd, &cmd, 1)) {
             break;
         }
@@ -1282,6 +1486,10 @@ static void rpc_serve_client(ggml_backend_t backend, const char * cache_dir,
             break;
         }
         switch (cmd) {
+            case RPC_CMD_HELLO: {
+                // HELLO command is handled above
+                return;
+            }
             case RPC_CMD_ALLOC_BUFFER: {
                 rpc_msg_alloc_buffer_req request;
                 if (!recv_msg(sockfd, &request, sizeof(request))) {
@@ -1462,6 +1670,20 @@ static void rpc_serve_client(ggml_backend_t backend, const char * cache_dir,
                 }
                 break;
             }
+            case RPC_CMD_SUPPORT_OP: {
+                std::vector<uint8_t> input;
+                if (!recv_msg(sockfd, input)) {
+                    return;
+                }
+                rpc_msg_support_op_rsp response;
+                if (!server.support_op(input, response)) {
+                    return;
+                }
+                if (!send_msg(sockfd, &response, sizeof(response))) {
+                    return;
+                }
+                break;
+            }
             default: {
                 fprintf(stderr, "Unknown command: %d\n", cmd);
                 return;
@@ -1574,10 +1796,26 @@ static ggml_backend_buffer_type_t ggml_backend_rpc_device_get_buffer_type(ggml_b
 }
 
 static bool ggml_backend_rpc_device_supports_op(ggml_backend_dev_t dev, const struct ggml_tensor * op) {
+    static std::unordered_map<std::string, std::unordered_map<std::string, bool>> caches;
+    ggml_backend_rpc_device_context * ctx = (ggml_backend_rpc_device_context *)dev->context;
+
+    auto &cache = caches[ctx->endpoint];
+    std::string key = op->name;
+    key += std::to_string(op->type);
+    for (int i = 0; i < GGML_MAX_DIMS; i++) {
+        key += std::to_string(op->ne[i]);
+    }
+    key += std::to_string(op->op);
+
+    auto it = cache.find(key);
+    if (it != cache.end()) {
+        return it->second;
+    }
+    bool result = ggml_backend_rpc_support_op(ctx->endpoint.c_str(), op);
+    cache[key] = result;
+    return result;
+
     GGML_UNUSED(dev);
-    GGML_UNUSED(op);
-    //TODO: call the remote backend and cache the results
-    return true;
 }
 
 static bool ggml_backend_rpc_device_supports_buft(ggml_backend_dev_t dev, ggml_backend_buffer_type_t buft) {
